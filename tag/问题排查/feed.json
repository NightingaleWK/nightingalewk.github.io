{
    "version": "https://jsonfeed.org/version/1",
    "title": "雪漫城的风宅 • All posts by \"问题排查\" tag",
    "description": "この世界は好都合に未完成 だから知りたいんだ —— チ。-地球の運動について-",
    "home_page_url": "https://nightingalewk.cn",
    "items": [
        {
            "id": "https://nightingalewk.cn/2025/10/13/80.%20Laravel%20%E9%A1%B9%E7%9B%AE%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%90%8E%EF%BC%8C%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5%E5%A4%9A%E5%87%BA%E4%B8%AA%2080%20%E7%AB%AF%E5%8F%A3%E5%AD%97%E6%A0%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "url": "https://nightingalewk.cn/2025/10/13/80.%20Laravel%20%E9%A1%B9%E7%9B%AE%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%90%8E%EF%BC%8C%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5%E5%A4%9A%E5%87%BA%E4%B8%AA%2080%20%E7%AB%AF%E5%8F%A3%E5%AD%97%E6%A0%B7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
            "title": "Laravel 项目容器化部署生产环境后，资源链接多出个 80 端口字样解决方案",
            "date_published": "2025-10-13T02:00:00.000Z",
            "content_html": "<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近在阿里云服务器上部署一个基于 Laravel 12 + Filament v4 的项目（代号“土豆食堂”），使用 Docker Compose 容器化部署，后端 Nginx + PHP-FPM，前端通过 Nginx Proxy Manager (NPM) 实现 HTTPS 反向代理。部署完成后，一切看似正常，但访问应用时发现前端资源（如 Filament 的 <code>app.js</code>）的 URL 被错误生成成 <code>https://lynx.wkarrow.top:80/js/filament/filament/app.js?v=4.1.6.0</code>，多出的 <code>:80</code> 端口导致浏览器无法加载资源，报 404 错误。</p>\n<p>这不是代码 bug，而是典型的 HTTPS 代理到 HTTP 后端的头部传递问题。NPM 默认将 <code>X-Forwarded-Port</code> 设置为后端端口 80，而 Laravel 在生成资产 URL 时会根据此头部附加端口，导致与 HTTPS scheme 不匹配。</p>\n<p>本文记录了问题排查与最终解决方案，重点分享后端 Nginx 的备选修复方法（适用于 NPM 配置无效的情况）。希望对类似部署遇到坑的开发者有帮助！</p>\n<h2 id=\"问题复现与分析\"><a href=\"#问题复现与分析\" class=\"headerlink\" title=\"问题复现与分析\"></a>问题复现与分析</h2><h3 id=\"环境概述\"><a href=\"#环境概述\" class=\"headerlink\" title=\"环境概述\"></a>环境概述</h3><ul>\n<li><strong>项目</strong>：Laravel 12 + Filament v4，使用 Vite 构建前端资源。</li>\n<li><strong>部署</strong>：Docker Compose（<code>docker-compose.internet.yml</code>），包含 app (PHP-FPM)、nginx、mysql、redis 等服务。</li>\n<li><strong>代理</strong>：NPM 监听 443 端口，强制 HTTPS，转发到后端 Nginx 的 80 端口。</li>\n<li><strong>Nginx 配置</strong>：<code>default.conf</code> 中已传递 <code>X-Forwarded-*</code> 头部到 PHP-FPM。</li>\n</ul>\n<h3 id=\"故障现象\"><a href=\"#故障现象\" class=\"headerlink\" title=\"故障现象\"></a>故障现象</h3><ul>\n<li>正常预期：<code>https://lynx.wkarrow.top/js/filament/filament/app.js?v=4.1.6.0</code></li>\n<li>实际生成：<code>https://lynx.wkarrow.top:80/js/filament/filament/app.js?v=4.1.6.0</code></li>\n<li>影响：浏览器 Network 面板显示资源 404，应用界面 JS&#x2F;CSS 加载失败，Filament 面板无法交互。</li>\n</ul>\n<h3 id=\"根因分析\"><a href=\"#根因分析\" class=\"headerlink\" title=\"根因分析\"></a>根因分析</h3><ol>\n<li>NPM 作为前端代理，添加 <code>X-Forwarded-Proto: https</code> 和 <code>X-Forwarded-Port: 80</code>（后端端口）。</li>\n<li>后端 Nginx 将这些头部传递给 PHP-FPM（<code>fastcgi_param HTTP_X_FORWARDED_PORT $http_x_forwarded_port;</code>）。</li>\n<li>Laravel 的 <code>Request</code> 对象信任代理头部（<code>config/trustedproxies.php</code>），读取 <code>X-Forwarded-Port=80</code>。</li>\n<li>URL 生成器（如 <code>asset()</code> 或 Filament 的资源 URL）检测到端口非 HTTPS 默认 443，故附加 <code>:80</code>。</li>\n<li>参考 Laravel 12 文档（HTTP Requests 部分）：<code>request()-&gt;getPort()</code> 优先从 <code>X-Forwarded-Port</code> 取值，导致畸形 URL。</li>\n</ol>\n<p>这是一个常见痛点，尤其在 Docker + 反向代理环境中。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>我先尝试了在 NPM 的 Advanced 选项卡添加 <code>proxy_set_header X-Forwarded-Port 443;</code>，但由于 NPM 的自定义配置有时不稳定（可能与版本或缓存相关），最终选择了后端 Nginx 的备选修复——直接在 <code>default.conf</code> 中覆盖端口逻辑。这方法更可靠，且不依赖代理工具。</p>\n<h3 id=\"步骤：修改后端-Nginx-配置\"><a href=\"#步骤：修改后端-Nginx-配置\" class=\"headerlink\" title=\"步骤：修改后端 Nginx 配置\"></a>步骤：修改后端 Nginx 配置</h3><ol>\n<li><p><strong>编辑配置文件</strong>：在项目目录下，打开 <code>./docker-internet/nginx/default.conf</code>（或挂载路径 <code>/etc/nginx/conf.d/default.conf</code>）。</p>\n</li>\n<li><p><strong>定位 PHP 处理块</strong>：找到 <code>location ~ \\.php$</code> 部分（已存在 FastCGI 配置）。</p>\n</li>\n<li><p><strong>添加覆盖逻辑</strong>：在 <code>fastcgi_param</code> 相关行后，插入以下 Nginx 指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~ \\.php$ &#123;</span><br><span class=\"line\">    try_files $uri =404;</span><br><span class=\"line\">    fastcgi_split_path_info ^(.+\\.php)(/.+)$;</span><br><span class=\"line\">    fastcgi_pass app:9000;</span><br><span class=\"line\">    fastcgi_index index.php;</span><br><span class=\"line\">    include fastcgi_params;</span><br><span class=\"line\">    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class=\"line\">    fastcgi_param PATH_INFO $fastcgi_path_info;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 原有头部传递</span><br><span class=\"line\">    fastcgi_param HTTP_X_FORWARDED_FOR $http_x_forwarded_for;</span><br><span class=\"line\">    fastcgi_param HTTP_X_FORWARDED_PROTO $http_x_forwarded_proto;</span><br><span class=\"line\">    fastcgi_param HTTP_X_FORWARDED_HOST $http_x_forwarded_host;</span><br><span class=\"line\">    fastcgi_param HTTP_X_FORWARDED_PORT $http_x_forwarded_port;</span><br><span class=\"line\"></span><br><span class=\"line\">    # 新增：基于 proto 覆盖端口，确保 HTTPS 时为 443</span><br><span class=\"line\">    set $real_port $http_x_forwarded_port;</span><br><span class=\"line\">    if ($http_x_forwarded_proto = &quot;https&quot;) &#123;</span><br><span class=\"line\">        set $real_port &quot;443&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fastcgi_param HTTP_X_FORWARDED_PORT $real_port;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>解释</strong>：<ul>\n<li><code>set $real_port $http_x_forwarded_port;</code>：默认使用传入端口。</li>\n<li><code>if ($http_x_forwarded_proto = &quot;https&quot;) &#123; set $real_port &quot;443&quot;; &#125;</code>：如果 scheme 是 HTTPS，则强制覆盖为 443（忽略后端 80）。</li>\n<li>最后用 <code>$real_port</code> 替换原参数，确保 Laravel 读取正确端口。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>保存并重启服务</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker compose -f docker-compose.internet.yml restart nginx</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Nginx 会优雅重载，无需重建整个容器。</li>\n</ul>\n</li>\n<li><p><strong>辅助优化</strong>（可选，但推荐）：</p>\n<ul>\n<li>确认 <code>.env</code> 中的 <code>APP_URL=https://lynx.wkarrow.top</code>（无端口）。</li>\n<li>清除 Laravel 缓存：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker compose -f docker-compose.internet.yml exec app php artisan config:clear</span><br><span class=\"line\">sudo docker compose -f docker-compose.internet.yml exec app php artisan cache:clear</span><br><span class=\"line\">sudo docker compose -f docker-compose.internet.yml exec app php artisan optimize</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"验证与测试\"><a href=\"#验证与测试\" class=\"headerlink\" title=\"验证与测试\"></a>验证与测试</h2><ul>\n<li><strong>浏览器测试</strong>：清空缓存，访问 <code>https://lynx.wkarrow.top</code>，打开 F12 &gt; Network，检查资源 URL（如 <code>app.js</code>）是否无 <code>:80</code>，并确认 200 OK。</li>\n<li><strong>命令行验证</strong>：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -I https://lynx.wkarrow.top/js/filament/filament/app.js</span><br></pre></td></tr></table></figure>\n预期返回 200，无重定向或 404。</li>\n<li><strong>日志检查</strong>：若仍有问题，查看容器日志：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker compose -f docker-compose.internet.yml logs nginx app | grep -i &quot;forwarded\\|port&quot;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>修复后，Filament 面板加载顺畅，前端交互完美！</p>\n<h2 id=\"总结与建议\"><a href=\"#总结与建议\" class=\"headerlink\" title=\"总结与建议\"></a>总结与建议</h2><p>这个坑让我意识到，在容器化部署中，代理头部的处理至关重要。优先尝试 NPM 的 Advanced 配置，如果无效，后端 Nginx 的 <code>if</code> 逻辑是稳妥备选。未来更新项目时，记得 git pull 后检查此配置是否覆盖。</p>\n<p>如果您也遇到类似问题，欢迎评论区交流！项目源码在 <a href=\"https://github.com/NightingaleWK/lynx\">GitHub</a> 开源中，星标支持下～</p>\n<p><strong>参考</strong>：</p>\n<ul>\n<li>Laravel 12 文档：HTTP Requests</li>\n<li>Nginx Proxy Manager 官方指南：Advanced Tab</li>\n</ul>\n<hr>\n<p><em>本文基于实际部署经验撰写，如有疑问，欢迎讨论。</em></p>\n",
            "tags": [
                "Laravel",
                "Docker",
                "Nginx",
                "反向代理",
                "NPM",
                "HTTPS",
                "问题排查"
            ]
        }
    ]
}